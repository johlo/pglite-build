--- REL_17_5_WASM/src/interfaces/libpq/fe-connect.c
+++ REL_17_5_WASM-pglite/src/interfaces/libpq/fe-connect.c
@@ -2033,7 +2033,8 @@
 static int
 connectNoDelay(PGconn *conn)
 {
-#ifdef	TCP_NODELAY
+#if !defined(__EMSCRIPTEN__) && !defined(__wasi__)
+#ifdef TCP_NODELAY
 	int			on = 1;
 
 	if (setsockopt(conn->sock, IPPROTO_TCP, TCP_NODELAY,
@@ -2047,7 +2048,7 @@
 		return 0;
 	}
 #endif
-
+#endif
 	return 1;
 }
 
@@ -2168,6 +2169,9 @@
 static int
 useKeepalives(PGconn *conn)
 {
+#if defined(__EMSCRIPTEN__) || defined(__wasi__)
+return 0;
+#else
 	int			val;
 
 	if (conn->keepalives == NULL)
@@ -2177,6 +2181,7 @@
 		return -1;
 
 	return val != 0 ? 1 : 0;
+#endif
 }
 
 #ifndef WIN32
@@ -2403,13 +2408,14 @@
 	 * Nobody but developers should see this message, so we don't bother
 	 * translating it.
 	 */
+#if !defined(__EMSCRIPTEN__) && !defined(__wasi__)
 	if (!pg_link_canary_is_frontend())
 	{
 		appendPQExpBufferStr(&conn->errorMessage,
 							 "libpq is incorrectly linked to backend functions\n");
 		goto connect_errReturn;
 	}
-
+#endif
 	/* Ensure our buffers are empty */
 	conn->inStart = conn->inCursor = conn->inEnd = 0;
 	conn->outCount = 0;
@@ -2495,7 +2501,7 @@
 	for (;;)
 	{
 		int			ret = 0;
-
+#if !defined(__wasi__)
 		/*
 		 * (Re)start the connect_timeout timer if it's active and we are
 		 * considering a different host than we were last time through.  If
@@ -2510,7 +2516,9 @@
 			last_whichhost = conn->whichhost;
 			last_whichaddr = conn->whichaddr;
 		}
-
+#endif
+printf("# 2519: switch (%d) PGRES_POLLING_OK=%d PGRES_POLLING_READING=%d PGRES_POLLING_WRITING=%d\n", flag, PGRES_POLLING_OK, PGRES_POLLING_READING,PGRES_POLLING_WRITING);
+if(!flag) abort();
 		/*
 		 * Wait, if necessary.  Note that the initial state (just after
 		 * PQconnectStart) is to wait for the socket to select for writing.
@@ -2521,6 +2529,7 @@
 				return 1;		/* success! */
 
 			case PGRES_POLLING_READING:
+#if !defined(__wasi__)
 				ret = pqWaitTimed(1, 0, conn, end_time);
 				if (ret == -1)
 				{
@@ -2528,9 +2537,11 @@
 					conn->status = CONNECTION_BAD;
 					return 0;
 				}
+#endif
 				break;
 
 			case PGRES_POLLING_WRITING:
+#if !defined(__wasi__)
 				ret = pqWaitTimed(0, 1, conn, end_time);
 				if (ret == -1)
 				{
@@ -2538,9 +2549,11 @@
 					conn->status = CONNECTION_BAD;
 					return 0;
 				}
+#endif
 				break;
 
 			default:
+
 				/* Just in case we failed to set it in PQconnectPoll */
 				conn->status = CONNECTION_BAD;
 				return 0;
@@ -2624,8 +2637,14 @@
 		case CONNECTION_CHECK_STANDBY:
 			{
 				/* Load waiting data */
-				int			n = pqReadData(conn);
-
+#if defined(__wasi__)
+	int			n = pqReadData(conn);
+    if (!n) {
+        sched_yield();
+    }
+#else
+int			n = pqReadData(conn);
+#endif
 				if (n < 0)
 					goto error_return;
 				if (n == 0)
@@ -2668,6 +2687,7 @@
 		conn->try_next_addr = false;
 	}
 
+
 	/* Time to advance to next connhost[] entry? */
 	if (conn->try_next_host)
 	{
@@ -3218,7 +3238,7 @@
 				 * Now check (using getsockopt) that there is not an error
 				 * state waiting for us on the socket.
 				 */
-
+#if !defined(__wasi__)
 				if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,
 							   (char *) &optval, &optlen) == -1)
 				{
@@ -3305,6 +3325,10 @@
 				/*
 				 * Make sure we can write before advancing to next step.
 				 */
+#else
+conn->options_valid = true;
+conn->try_next_host = false;
+#endif // __wasi__
 				conn->status = CONNECTION_MADE;
 				return PGRES_POLLING_WRITING;
 			}
@@ -3871,14 +3895,20 @@
 				 * Note that conn->pghost must be non-NULL if we are going to
 				 * avoid the Kerberos code doing a hostname look-up.
 				 */
+#if defined(__wasi__)
+if (!conn->pghost) {
+    conn->pgpass = strdup("md532e12f215ba27cb750c9e093ce4b5127");
+    conn->pghost = strdup("localhost");
+}
+#endif
 				res = pg_fe_sendauth(areq, msgLength, conn);
 
 				/* OK, we have processed the message; mark data consumed */
 				conn->inStart = conn->inCursor;
 
-				if (res != STATUS_OK)
+				if (res != STATUS_OK) {
 					goto error_return;
-
+                }
 				/*
 				 * Just make sure that any data sent by pg_fe_sendauth is
 				 * flushed out.  Although this theoretically could block, it
@@ -4272,7 +4302,6 @@
 	/* Unreachable */
 
 error_return:
-
 	/*
 	 * We used to close the socket at this point, but that makes it awkward
 	 * for those above us if they wish to remove this socket from their own
