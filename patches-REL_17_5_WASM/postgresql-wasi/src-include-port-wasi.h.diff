--- REL_17_5_WASM/src/include/port/wasi.h
+++ pglite-REL_17_5_WASM/src/include/port/wasi.h
@@ -1,17 +1,336 @@
-/* src/include/port/{wasi/emscripten}.h */
+#pragma once
 
-#ifndef I_WASM
-#define I_WASM
+#ifndef I_WASI
+#define I_WASI
 
-#if !defined(__cplusplus)
-#include <sdk_port.h>
+#undef HAVE_PTHREAD
+
+#if defined(HAVE_SETSID)
+#undef HAVE_SETSID
+#endif
+
+#if defined(HAVE_GETRLIMIT)
+#undef HAVE_GETRLIMIT
 #endif
 
+
+#define PLATFORM_DEFAULT_SYNC_METHOD    SYNC_METHOD_FDATASYNC
+
+#define EMSCRIPTEN_KEEPALIVE __attribute__((used))
+#define __declspec( dllimport ) __attribute__((used))
+
+#define em_callback_func void
+#define emscripten_set_main_loop(...)
+#define emscripten_force_exit(...)
+#define EM_JS(...)
+
+
 #include "/tmp/pglite/include/wasm_common.h"
 
 
-#define BOOT_END_MARK "build indices"
-#define FD_BUFFER_MAX 16384
+#define system(command) system_wasi(command)
+extern int system_wasi(const char *command);
+
+static pid_t
+fork(void) {
+    puts("# 34:" __FILE__ ": fork -1");
+    return -1;
+}
+
+static int
+pipe(int fd[2]) {
+    puts("# 40: pipe");
+    abort();
+    return -1;
+}
+
+/*
+struct __wasi_addrinfo_t{
+  int32_t ai_flags;
+  int32_t ai_family;
+  int32_t ai_socktype;
+  int32_t ai_protocol;
+  __wasi_size_t ai_addrlen;
+  __wasi_address_t* ai_addr;
+  //__wasi_size_t ai_canonname_len;
+  uint32_t ai_canonname;
+  struct __wasi_addrinfo_t** ai_next;
+};
+*/
+
+#include <arpa/inet.h> // for inet_pton
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+/* extern one is not valid in wasip2
+extern int getaddrinfo(const char *restrict node,
+                       const char *restrict service,
+                       const struct addrinfo *restrict hints,
+                       struct addrinfo **restrict res);
+*/
+
+
+/*
+static int getaddrinfo(const char *hostname, const char *service,
+                   const struct addrinfo *hints, struct addrinfo **res) {
+    struct addrinfo *result = malloc(sizeof(struct addrinfo));
+    if (!result) return EAI_MEMORY;
+
+    memset(result, 0, sizeof(struct addrinfo));
+    result->ai_family = AF_INET;
+    result->ai_socktype = SOCK_STREAM;
+    result->ai_protocol = IPPROTO_TCP;
+
+    struct sockaddr_in *addr = malloc(sizeof(struct sockaddr_in));
+    if (!addr) {
+        free(result);
+        return EAI_MEMORY;
+    }
+
+    addr->sin_family = AF_INET;
+    addr->sin_port = htons(atoi(service));
+    if (inet_pton(AF_INET, hostname, &(addr->sin_addr)) <= 0) {
+        free(result);
+        free(addr);
+        return EAI_FAIL;
+    }
+
+    result->ai_addr = (struct sockaddr *)addr;
+    result->ai_addrlen = sizeof(struct sockaddr_in);
+    result->ai_next = NULL;
+
+    *res = result;
+    return 0;
+}
+
+*/
+
+
+
+// ============= signal ==============
+
+#define SA_RESTART 4
+#define SIG_SETMASK   2
+
+#define SIG_BLOCK     0
+#define SIG_UNBLOCK   1
+
+/* A signal handler.  */
+typedef void (*handler_t) (int signal);
+typedef unsigned char sigset_t;
+typedef void (*__sighandler_t) (int);
+
+struct sigaction {
+    __sighandler_t sa_handler;
+    unsigned long sa_flags;
+#ifdef SA_RESTORER
+    __sigrestore_t sa_restorer;
+#endif
+    sigset_t sa_mask;
+};
+
+extern int sigemptyset(sigset_t *set);
+extern int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
+extern int sigdelset (sigset_t *set, int sig);
+extern int sigfillset (sigset_t *set);
+extern int sigprocmask (int operation, const sigset_t *set, sigset_t *old_set);
+extern int sigaddset (sigset_t *set, int sig);
+
+
+
+
+#include <unistd.h> // for uid_t, pid_t
+static uid_t
+getuid(void) {
+    return 1000;
+}
+
+
+
+
+// WIP: semaphores
+// https://github.com/bytecodealliance/wasm-micro-runtime/issues/3054
+#include <sys/sem.h>
+
+static int
+semctl(int semid, int semnum, int cmd, ...) {
+    return 0; // -1;
+}
+
+static int
+semget(key_t key, int nsems, int semflg) {
+#if 0 // PGDEBUG
+    printf("# 120: semget(key_t key = %d, int nsems=%d, int semflg=%d)\n", key, nsems, semflg);
+#endif
+    return 1;
+}
+
+static int
+semop(int semid, struct sembuf *sops, size_t nsops) {
+    return 0;  // -1;
+}
+
+static int
+dup(int fd) {
+    puts("# 132: dup");
+    return fd;
+}
+
+static int
+dup2(int old, int new) {
+    puts("# 138:" __FILE__ ": dup2");
+    return -1;
+}
+
+
+// <sys/resource.h>
+
+#define RLIMIT_NOFILE 7
+#define RLIMIT_STACK 3
+#define RLIM_INFINITY ((unsigned long int)(~0UL))
+
+
+struct rlimit {
+    unsigned long   rlim_cur;
+    unsigned long   rlim_max;
+};
+
+static int
+getrlimit(int resource, struct rlimit *rlim) {
+    return -1;
+}
+
+/*
+
+static int
+getrusage(int who, struct rusage *usage) {
+    return -1;
+}
+*/
+
+// STUBS
+extern int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
+extern int sigwait(const sigset_t *restrict set, int *restrict sig);
+extern int sigismember(const sigset_t *set, int signum);
+extern int sigpending(sigset_t *set);
+
+
+// ****************************************************************************************
+// ****************************************************************************************
+// ****************************************************************************************
+// ****************************************************************************************
+
+
+#ifndef __wasi__p2
+
+
+// ======== signal ========================
+
+
+
+// ====================================================
+// unistd
+extern unsigned int alarm(unsigned int seconds);
+
+// ====================================================
+
+/*
+#include <setjmp.h>
+
+static int
+sigsetjmp(sigjmp_buf env, int savesigs) {
+//    puts("# 201: sigsetjmp");
+    return 0;
+}
+
+static void
+siglongjmp(sigjmp_buf env, int val) {
+    puts("# 207: siglongjmp");
+}
+*/
+
+
+// WIP :
+
+#include <sys/mman.h>
+#if defined(PYDK)
+extern int shm_open(const char *name, int oflag, mode_t mode);
+extern int shm_unlink(const char *name);
+#else
+static int
+shm_open(const char *name, int oflag, mode_t mode) {
+    char tmpnam[128];
+    int fd;
+    snprintf(tmpnam, 128, "/tmp%s", name);
+    fd=fileno(fopen(tmpnam, "w+"));
+    fprintf(stderr, "# 212: shm_open(%s) => %d\n", tmpnam, fd);
+    return fd;
+}
+
+static int
+shm_unlink(const char *name) {
+    char tmpnam[128];
+    snprintf(tmpnam, 128, "/tmp%s", name);
+    fprintf(stderr, "# 220: shm_unlink(%s) STUB\n", tmpnam);
+    return remove(tmpnam); // -1
+}
+
+#endif
+
+
+// time.h
+
+static void
+tzset(void) {
+    puts("# 241: tzset(void) STUB");
+}
+
+#if defined(PG_INITDB) || defined(FE_UTILS_PRINT) || defined(PG_DUMP_PARALLEL)
+static void
+__SIG_IGN(int param) {
+}
+#endif
+
+
+
+
+// TODO: socket here
+// ==================================================================
+
+#include <sys/socket.h>
+
+//extern ssize_t sdk_recv(int sockfd, void *buf, size_t len, int flags);
+//extern ssize_t recvfrom(int socket, void *buffer, size_t length, int flags, void *address, socklen_t *address_len);
+
+//extern ssize_t sdk_send(int sockfd, const void *buf, size_t len, int flags);
+//extern ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, void *dest_addr, socklen_t addrlen);
+
+
+
+
+static int
+listen(int sockfd, int backlog) {
+    return 0;
+}
+
+static struct group *_Nullable
+getgrnam(const char *_Nullable name) {
+    return NULL;
+}
+
+//#define pthread_mutex_lock(mut) sdk_pthread_mutex_lock(mut)
+//extern int sdk_pthread_mutex_lock(void *mutex);
+
+/*
+       int pthread_mutex_lock(pthread_mutex_t *mutex);
+       int pthread_mutex_trylock(pthread_mutex_t *mutex);
+       int pthread_mutex_unlock(pthread_mutex_t *mutex);
+*/
+
+#endif // __wasi__p2
+
+#endif // I_WASI
+
 
 
-#endif // I_WASM
