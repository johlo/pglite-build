#!/usr/bin/env python3
"""
Generate a WASI dlsym header for a contrib extension by parsing its SQL files.
"""

from __future__ import annotations

import argparse
import re
from pathlib import Path


def strip_comments(sql: str) -> str:
    sql = re.sub(r"/\*.*?\*/", "", sql, flags=re.S)
    sql = re.sub(r"--[^\n]*", "", sql)
    return sql


def extract_symbols(sql: str) -> set[str]:
    symbols: set[str] = set()
    for stmt in re.split(r";", sql):
        if not re.search(r"\bCREATE\b", stmt, re.I):
            continue
        if not re.search(r"\bFUNCTION\b", stmt, re.I):
            continue
        if not re.search(r"\bLANGUAGE\s+C\b", stmt, re.I):
            continue
        if not re.search(r"MODULE_PATHNAME", stmt, re.I):
            continue

        fn_match = re.search(
            r"CREATE\s+(?:OR\s+REPLACE\s+)?FUNCTION\s+([^\s(]+)",
            stmt,
            re.I,
        )
        if not fn_match:
            continue
        fn_name = fn_match.group(1).split(".")[-1].strip('"')

        as_match = re.search(
            r"AS\s+'MODULE_PATHNAME'\s*(?:,\s*'([^']+)')?",
            stmt,
            re.I,
        )
        if not as_match:
            continue

        sym = (as_match.group(1) or fn_name).split(".")[-1].strip('"')
        if sym:
            symbols.add(sym)
    return symbols


def generate_header(ext: str, symbols: list[str]) -> str:
    guard = f"WASI_{ext.upper()}_SYMS_H"
    lines: list[str] = []
    lines.append("/* Auto-generated by gen_wasi_ext_syms.py. */")
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")
    lines.append("#include <stddef.h>")
    lines.append("#include <string.h>")
    lines.append("")
    lines.append(f"#define HAVE_WASI_{ext.upper()}_SYMS 1")
    lines.append("")
    for sym in symbols:
        lines.append(f"extern void {sym}(void);")
        lines.append(f"extern void pg_finfo_{sym}(void);")
    lines.append("")
    lines.append("typedef struct { const char *name; void *addr; } wasi_ext_sym_t;")
    lines.append(f"static const wasi_ext_sym_t wasi_{ext}_syms[] = {{")
    for sym in symbols:
        lines.append(f'    {{"{sym}", (void *)&{sym}}},')
        lines.append(f'    {{"pg_finfo_{sym}", (void *)&pg_finfo_{sym}}},')
    lines.append("};")
    lines.append("")
    lines.append(f"static inline void *wasi_{ext}_dlsym(const char *symbol) {{")
    lines.append("    if (!symbol) return NULL;")
    lines.append(
        f"    for (size_t i = 0; i < sizeof(wasi_{ext}_syms) / sizeof(wasi_{ext}_syms[0]); i++) {{"
    )
    lines.append("        if (strcmp(symbol, wasi_%s_syms[i].name) == 0) return wasi_%s_syms[i].addr;" % (ext, ext))
    lines.append("    }")
    lines.append("    return NULL;")
    lines.append("}")
    lines.append("")
    lines.append(f"#endif /* {guard} */")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--ext", required=True, help="extension name (e.g. hstore)")
    parser.add_argument("--sql-dir", required=True, help="path to contrib extension sql dir")
    parser.add_argument("--out", required=True, help="output header path")
    args = parser.parse_args()

    sql_dir = Path(args.sql_dir)
    if not sql_dir.is_dir():
        raise SystemExit(f"sql dir not found: {sql_dir}")

    sql_files = sorted(sql_dir.glob(f"{args.ext}--*.sql"))
    if not sql_files:
        raise SystemExit(f"no sql files found for {args.ext} in {sql_dir}")

    symbols: set[str] = set()
    for sql_file in sql_files:
        sql = strip_comments(sql_file.read_text(encoding="utf-8"))
        symbols.update(extract_symbols(sql))

    if not symbols:
        raise SystemExit(f"no C symbols found in {sql_dir}")

    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(
        generate_header(args.ext, sorted(symbols)),
        encoding="utf-8",
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
